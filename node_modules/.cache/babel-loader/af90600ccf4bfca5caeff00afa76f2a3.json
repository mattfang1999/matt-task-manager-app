{"ast":null,"code":"var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$();\n\nimport { useState, useEffect } from 'react';\nimport { firebase } from '../firebase';\nimport { collatedTasksExist } from '../helpers';\nimport moment from 'moment';\nexport const useTasks = selectedProject => {\n  _s();\n\n  const [tasks, setTasks] = useState([]);\n  const [archivedTasks, setArchivedTasks] = useState([]);\n  useEffect(() => {\n    let unsubscribe = firebase.firestore().collection('tasks').where('userId', '==', 'nfeCumoN');\n    unsubscribe = selectedProject && !collatedTasksExist(selectedProject) ? unsubscribe = unsubscribe.where('projectId', '==', selectedProject) : selectedProject === 'TODAY' ? unsubscribe = unsubscribe.where('date', '==', moment().format('DD/MM/YYYY')) : selectedProject === 'INBOX' || selectedProject === 0 ? unsubscribe = unsubscribe.where('date', '==', '') : unsubscribe; //-------------------------Getting tasks for next 7 days \n\n    unsubscribe = unsubscribe.onSnapshot(snapshot => {\n      const newTasks = snapshot.docs.map(task => ({\n        id: task.id,\n        ...task.data()\n      }));\n      setTasks(selectedProject === 'NEXT_7' ? newTasks.filter(task => moment(task.date, 'DD-MM-YYYY').diff(moment(), 'days') <= 7 && task.archived !== true) : newTasks.filter(task => task.archived !== true));\n      setArchivedTasks(newTasks.filter(task => task.archived !== false));\n    }); //only want to check the projects when there's a new selected project\n    //all this code will run when selectedProject changes \n\n    return () => unsubscribe();\n  }, [selectedProject]);\n  return {\n    tasks,\n    archivedTasks\n  };\n};\n\n_s(useTasks, \"lkbYbSuB/cNTkTVEXjLheUMZ+l8=\");\n\nexport const useProjects = () => {\n  _s2();\n\n  const [projects, setProjects] = useState([]);\n  useEffect(() => {\n    firebase.firestore().collection('projects').where('userId', '==', 'jlIFXIwyAL3tzHMtzRbw').orderBy('projectId').get().then(snapshot => {\n      const allProjects = snapshot.docs.map(project => ({ ...project.data(),\n        docId: project.id\n      }));\n\n      if (JSON.stringify(allProjects) !== JSON.stringify(projects)) {\n        setProjects(allProjects);\n      }\n    });\n  }, [projects]);\n  return {\n    projects,\n    setProjects\n  };\n}; //   import { useState, useEffect } from 'react';\n// import moment from 'moment';\n// import { firebase } from '../firebase';\n// import { collatedTasksExist } from '../helpers';\n// export const useTasks = selectedProject => {\n//   const [tasks, setTasks] = useState([]);\n//   const [archivedTasks, setArchivedTasks] = useState([]);\n//   useEffect(() => {\n//     let unsubscribe = firebase\n//       .firestore()\n//       .collection('tasks')\n//       .where('userId', '==', 'jlIFXIwyAL3tzHMtzRbw');\n//     unsubscribe =\n//       selectedProject && !collatedTasksExist(selectedProject)\n//         ? (unsubscribe = unsubscribe.where('projectId', '==', selectedProject))\n//         : selectedProject === 'TODAY'\n//         ? (unsubscribe = unsubscribe.where(\n//             'date',\n//             '==',\n//             moment().format('DD/MM/YYYY')\n//           ))\n//         : selectedProject === 'INBOX' || selectedProject === 0\n//         ? (unsubscribe = unsubscribe.where('date', '==', ''))\n//         : unsubscribe;\n//     unsubscribe = unsubscribe.onSnapshot(snapshot => {\n//       const newTasks = snapshot.docs.map(task => ({\n//         id: task.id,\n//         ...task.data(),\n//       }));\n//       setTasks(\n//         selectedProject === 'NEXT_7'\n//           ? newTasks.filter(\n//               task =>\n//                 moment(task.date, 'DD-MM-YYYY').diff(moment(), 'days') <= 7 &&\n//                 task.archived !== true\n//             )\n//           : newTasks.filter(task => task.archived !== true)\n//       );\n//       setArchivedTasks(newTasks.filter(task => task.archived !== false));\n//     });\n//     return () => unsubscribe();\n//   }, [selectedProject]);\n//   return { tasks, archivedTasks };\n// };\n// export const useProjects = () => {\n//   const [projects, setProjects] = useState([]);\n//   useEffect(() => {\n//     firebase\n//       .firestore()\n//       .collection('projects')\n//       .where('userId', '==', 'jlIFXIwyAL3tzHMtzRbw')\n//       .orderBy('projectId')\n//       .get()\n//       .then(snapshot => {\n//         const allProjects = snapshot.docs.map(project => ({\n//           ...project.data(),\n//           docId: project.id,\n//         }));\n//         if (JSON.stringify(allProjects) !== JSON.stringify(projects)) {\n//           setProjects(allProjects);\n//         }\n//       });\n//   }, [projects]);\n//   return { projects, setProjects };\n// };\n// const selectedProject = 1; \n// const { tasks, archivedTasks} = useTasks(selectedProject);\n//passing an empty array means we only want to run this once - after the component is mounted\n//without the array then it's just going to keep running over and over again\n//whatever is put into the array: if that chaanges, then the useEffect will run \n\n_s2(useProjects, \"TSrpuQX6QU8EgjQSxaAzj2u9i4o=\");","map":{"version":3,"sources":["/Users/matthewfang1999/Documents/CMU/F20/PUI/HW8/taskmanagerapp/src/hooks/index.js"],"names":["useState","useEffect","firebase","collatedTasksExist","moment","useTasks","selectedProject","tasks","setTasks","archivedTasks","setArchivedTasks","unsubscribe","firestore","collection","where","format","onSnapshot","snapshot","newTasks","docs","map","task","id","data","filter","date","diff","archived","useProjects","projects","setProjects","orderBy","get","then","allProjects","project","docId","JSON","stringify"],"mappings":"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","sourcesContent":["import { useState, useEffect} from 'react';\nimport { firebase } from  '../firebase';\nimport { collatedTasksExist } from '../helpers';\nimport moment from 'moment';\n\n\n\n\nexport const useTasks = selectedProject => {\n    const [tasks, setTasks] = useState([]);\n    const [archivedTasks, setArchivedTasks] = useState([]);\n  \n    useEffect(() => {\n      let unsubscribe = firebase\n        .firestore()\n        .collection('tasks')\n        .where('userId', '==', 'nfeCumoN');\n  \n      unsubscribe =\n        selectedProject && !collatedTasksExist(selectedProject)\n          ? (unsubscribe = unsubscribe.where('projectId', '==', selectedProject))\n          : selectedProject === 'TODAY'\n          ? (unsubscribe = unsubscribe.where(\n              'date',\n              '==',\n              moment().format('DD/MM/YYYY')\n            ))\n          : selectedProject === 'INBOX' || selectedProject === 0\n          ? (unsubscribe = unsubscribe.where('date', '==', ''))\n          : unsubscribe;\n\n//-------------------------Getting tasks for next 7 days \n      unsubscribe = unsubscribe.onSnapshot(snapshot => {\n        const newTasks = snapshot.docs.map(task => ({\n          id: task.id,\n          ...task.data(),\n        }));\n  \n        setTasks(\n          selectedProject === 'NEXT_7'\n            ? newTasks.filter(\n                task =>\n                  moment(task.date, 'DD-MM-YYYY').diff(moment(), 'days') <= 7 &&\n                  task.archived !== true\n              )\n            : newTasks.filter(task => task.archived !== true)\n        );\n        setArchivedTasks(newTasks.filter(task => task.archived !== false));\n      });\n  \n//only want to check the projects when there's a new selected project\n//all this code will run when selectedProject changes \n      return () => unsubscribe();\n    }, [selectedProject]);\n  \n    return { tasks, archivedTasks };\n  };\n\n\n\n\n\n\n\n  export const useProjects = () => {\n    const [projects, setProjects] = useState([]);\n  \n    useEffect(() => {\n      firebase\n        .firestore()\n        .collection('projects')\n        .where('userId', '==', 'jlIFXIwyAL3tzHMtzRbw')\n        .orderBy('projectId')\n        .get()\n        .then(snapshot => {\n          const allProjects = snapshot.docs.map(project => ({\n            ...project.data(),\n            docId: project.id,\n          }));\n  \n          if (JSON.stringify(allProjects) !== JSON.stringify(projects)) {\n            setProjects(allProjects);\n          }\n        });\n    }, [projects]);\n  \n    return { projects, setProjects };\n  };\n\n\n//   import { useState, useEffect } from 'react';\n// import moment from 'moment';\n// import { firebase } from '../firebase';\n// import { collatedTasksExist } from '../helpers';\n\n// export const useTasks = selectedProject => {\n//   const [tasks, setTasks] = useState([]);\n//   const [archivedTasks, setArchivedTasks] = useState([]);\n\n//   useEffect(() => {\n//     let unsubscribe = firebase\n//       .firestore()\n//       .collection('tasks')\n//       .where('userId', '==', 'jlIFXIwyAL3tzHMtzRbw');\n\n//     unsubscribe =\n//       selectedProject && !collatedTasksExist(selectedProject)\n//         ? (unsubscribe = unsubscribe.where('projectId', '==', selectedProject))\n//         : selectedProject === 'TODAY'\n//         ? (unsubscribe = unsubscribe.where(\n//             'date',\n//             '==',\n//             moment().format('DD/MM/YYYY')\n//           ))\n//         : selectedProject === 'INBOX' || selectedProject === 0\n//         ? (unsubscribe = unsubscribe.where('date', '==', ''))\n//         : unsubscribe;\n\n//     unsubscribe = unsubscribe.onSnapshot(snapshot => {\n//       const newTasks = snapshot.docs.map(task => ({\n//         id: task.id,\n//         ...task.data(),\n//       }));\n\n//       setTasks(\n//         selectedProject === 'NEXT_7'\n//           ? newTasks.filter(\n//               task =>\n//                 moment(task.date, 'DD-MM-YYYY').diff(moment(), 'days') <= 7 &&\n//                 task.archived !== true\n//             )\n//           : newTasks.filter(task => task.archived !== true)\n//       );\n//       setArchivedTasks(newTasks.filter(task => task.archived !== false));\n//     });\n\n//     return () => unsubscribe();\n//   }, [selectedProject]);\n\n//   return { tasks, archivedTasks };\n// };\n\n// export const useProjects = () => {\n//   const [projects, setProjects] = useState([]);\n\n//   useEffect(() => {\n//     firebase\n//       .firestore()\n//       .collection('projects')\n//       .where('userId', '==', 'jlIFXIwyAL3tzHMtzRbw')\n//       .orderBy('projectId')\n//       .get()\n//       .then(snapshot => {\n//         const allProjects = snapshot.docs.map(project => ({\n//           ...project.data(),\n//           docId: project.id,\n//         }));\n\n//         if (JSON.stringify(allProjects) !== JSON.stringify(projects)) {\n//           setProjects(allProjects);\n//         }\n//       });\n//   }, [projects]);\n\n//   return { projects, setProjects };\n// };\n\n\n\n// const selectedProject = 1; \n// const { tasks, archivedTasks} = useTasks(selectedProject);\n\n\n//passing an empty array means we only want to run this once - after the component is mounted\n//without the array then it's just going to keep running over and over again\n//whatever is put into the array: if that chaanges, then the useEffect will run "]},"metadata":{},"sourceType":"module"}