{"ast":null,"code":"import _objectSpread from\"/Users/matthewfang1999/Documents/CMU/F20/PUI/HW8/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";import _slicedToArray from\"/Users/matthewfang1999/Documents/CMU/F20/PUI/HW8/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import{useState,useEffect}from'react';import moment from'moment';import{firebase}from'../firebase';import{collatedTasksExist}from'../helpers';export var useTasks=function useTasks(selectedProject){var _useState=useState([]),_useState2=_slicedToArray(_useState,2),tasks=_useState2[0],setTasks=_useState2[1];var _useState3=useState([]),_useState4=_slicedToArray(_useState3,2),archivedTasks=_useState4[0],setArchivedTasks=_useState4[1];useEffect(function(){var unsubscribe=firebase.firestore().collection('tasks').where('userId','==','nfeCumoN');unsubscribe=selectedProject&&!collatedTasksExist(selectedProject)?unsubscribe=unsubscribe.where('projectId','==',selectedProject):selectedProject==='TODAY'?unsubscribe=unsubscribe.where('date','==',moment().format('DD/MM/YYYY')):selectedProject==='INBOX'||selectedProject===0?unsubscribe=unsubscribe.where('date','==',''):unsubscribe;unsubscribe=unsubscribe.onSnapshot(function(snapshot){var newTasks=snapshot.docs.map(function(task){return _objectSpread({id:task.id},task.data());});setTasks(selectedProject==='NEXT_7'?newTasks.filter(function(task){return moment(task.date,'DD-MM-YYYY').diff(moment(),'days')<=7&&task.archived!==true;}):newTasks.filter(function(task){return task.archived!==true;}));setArchivedTasks(newTasks.filter(function(task){return task.archived!==false;}));});return function(){return unsubscribe();};},[selectedProject]);return{tasks:tasks,archivedTasks:archivedTasks};};export var useProjects=function useProjects(){var _useState5=useState([]),_useState6=_slicedToArray(_useState5,2),projects=_useState6[0],setProjects=_useState6[1];useEffect(function(){firebase.firestore().collection('projects').where('userId','==','nfeCumoN').orderBy('projectId').get().then(function(snapshot){var allProjects=snapshot.docs.map(function(project){return _objectSpread(_objectSpread({},project.data()),{},{docId:project.id});});if(JSON.stringify(allProjects)!==JSON.stringify(projects)){setProjects(allProjects);}});},[projects]);return{projects:projects,setProjects:setProjects};};// const selectedProject = 1; \n// const { tasks, archivedTasks} = useTasks(selectedProject);\n//passing an empty array means we only want to run this once - after the component is mounted\n//without the array then it's just going to keep running over and over again\n//whatever is put into the array: if that chaanges, then the useEffect will run","map":{"version":3,"sources":["/Users/matthewfang1999/Documents/CMU/F20/PUI/HW8/src/hooks/index.js"],"names":["useState","useEffect","moment","firebase","collatedTasksExist","useTasks","selectedProject","tasks","setTasks","archivedTasks","setArchivedTasks","unsubscribe","firestore","collection","where","format","onSnapshot","snapshot","newTasks","docs","map","task","id","data","filter","date","diff","archived","useProjects","projects","setProjects","orderBy","get","then","allProjects","project","docId","JSON","stringify"],"mappings":"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","sourcesContent":["import { useState, useEffect } from 'react';\nimport moment from 'moment';\nimport { firebase } from '../firebase';\nimport { collatedTasksExist } from '../helpers';\n\nexport const useTasks = selectedProject => {\n  const [tasks, setTasks] = useState([]);\n  const [archivedTasks, setArchivedTasks] = useState([]);\n\n  useEffect(() => {\n    let unsubscribe = firebase\n      .firestore()\n      .collection('tasks')\n      .where('userId', '==', 'nfeCumoN');\n\n    unsubscribe =\n      selectedProject && !collatedTasksExist(selectedProject)\n        ? (unsubscribe = unsubscribe.where('projectId', '==', selectedProject))\n        : selectedProject === 'TODAY'\n        ? (unsubscribe = unsubscribe.where(\n            'date',\n            '==',\n            moment().format('DD/MM/YYYY')\n          ))\n        : selectedProject === 'INBOX' || selectedProject === 0\n        ? (unsubscribe = unsubscribe.where('date', '==', ''))\n        : unsubscribe;\n\n    unsubscribe = unsubscribe.onSnapshot(snapshot => {\n      const newTasks = snapshot.docs.map(task => ({\n        id: task.id,\n        ...task.data(),\n      }));\n\n      setTasks(\n        selectedProject === 'NEXT_7'\n          ? newTasks.filter(\n              task =>\n                moment(task.date, 'DD-MM-YYYY').diff(moment(), 'days') <= 7 &&\n                task.archived !== true\n            )\n          : newTasks.filter(task => task.archived !== true)\n      );\n      setArchivedTasks(newTasks.filter(task => task.archived !== false));\n    });\n\n    return () => unsubscribe();\n  }, [selectedProject]);\n\n  return { tasks, archivedTasks };\n};\n\nexport const useProjects = () => {\n  const [projects, setProjects] = useState([]);\n\n  useEffect(() => {\n    firebase\n      .firestore()\n      .collection('projects')\n      .where('userId', '==', 'nfeCumoN')\n      .orderBy('projectId')\n      .get()\n      .then(snapshot => {\n        const allProjects = snapshot.docs.map(project => ({\n          ...project.data(),\n          docId: project.id,\n        }));\n\n        if (JSON.stringify(allProjects) !== JSON.stringify(projects)) {\n          setProjects(allProjects);\n        }\n      });\n  }, [projects]);\n\n  return { projects, setProjects };\n};\n\n\n\n// const selectedProject = 1; \n// const { tasks, archivedTasks} = useTasks(selectedProject);\n\n\n//passing an empty array means we only want to run this once - after the component is mounted\n//without the array then it's just going to keep running over and over again\n//whatever is put into the array: if that chaanges, then the useEffect will run "]},"metadata":{},"sourceType":"module"}