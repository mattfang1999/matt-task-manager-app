{"ast":null,"code":"var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$();\n\n// import { useState, useEffect} from 'react';\n// import { firebase } from  '../firebase';\n// import { collatedTasksExist } from '../helpers';\n// import moment from 'moment';\n// export const useTasks = selectedProject => {\n//     const [tasks, setTasks] = useState([]);\n//     const [archivedTasks, setArchivedTasks] = useState([]);\n//     useEffect(() => {\n//       let unsubscribe = firebase\n//         .firestore()\n//         .collection('tasks')\n//         .where('userId', '==', 'nfeCumoN');\n//       unsubscribe =\n//         selectedProject && !collatedTasksExist(selectedProject)\n//           ? (unsubscribe = unsubscribe.where('projectId', '==', selectedProject))\n//           : selectedProject === 'TODAY'\n//           ? (unsubscribe = unsubscribe.where(\n//               'date',\n//               '==',\n//               moment().format('DD/MM/YYYY')\n//             ))\n//           : selectedProject === 'INBOX' || selectedProject === 0\n//           ? (unsubscribe = unsubscribe.where('date', '==', ''))\n//           : unsubscribe;\n// //-------------------------Getting tasks for next 7 days \n//       unsubscribe = unsubscribe.onSnapshot(snapshot => {\n//         const newTasks = snapshot.docs.map(task => ({\n//           id: task.id,\n//           ...task.data(),\n//         }));\n//         setTasks(\n//           selectedProject === 'NEXT_7'\n//             ? newTasks.filter(\n//                 task =>\n//                   moment(task.date, 'DD-MM-YYYY').diff(moment(), 'days') <= 7 &&\n//                   task.archived !== true\n//               )\n//             : newTasks.filter(task => task.archived !== true)\n//         );\n//         setArchivedTasks(newTasks.filter(task => task.archived !== false));\n//       });\n// //only want to check the projects when there's a new selected project\n// //all this code will run when selectedProject changes \n//       return () => unsubscribe();\n//     }, [selectedProject]);\n//     return { tasks, archivedTasks };\n//   };\n//   export const useProjects = () => {\n//     const [projects, setProjects] = useState([]);\n//     useEffect(() => {\n//       firebase\n//         .firestore()\n//         .collection('projects')\n//         .where('userId', '==', 'nfeCumoN')\n//         .orderBy('projectId')\n//         .get()\n//         .then(snapshot => {\n//           const allProjects = snapshot.docs.map(project => ({\n//             ...project.data(),\n//             docId: project.id,\n//           }));\n//           if (JSON.stringify(allProjects) !== JSON.stringify(projects)) {\n//             setProjects(allProjects);\n//           }\n//         });\n//     }, [projects]);\n//     return { projects, setProjects };\n//   };\nimport { useState, useEffect } from 'react';\nimport moment from 'moment';\nimport { firebase } from '../firebase';\nimport { collatedTasksExist } from '../helpers';\nexport const useTasks = selectedProject => {\n  _s();\n\n  const [tasks, setTasks] = useState([]);\n  const [archivedTasks, setArchivedTasks] = useState([]);\n  useEffect(() => {\n    let unsubscribe = firebase.firestore().collection('tasks').where('userId', '==', 'nfeCumoN');\n    unsubscribe = selectedProject && !collatedTasksExist(selectedProject) ? unsubscribe = unsubscribe.where('projectId', '==', selectedProject) : selectedProject === 'TODAY' ? unsubscribe = unsubscribe.where('date', '==', moment().format('DD/MM/YYYY')) : selectedProject === 'INBOX' || selectedProject === 0 ? unsubscribe = unsubscribe.where('date', '==', '') : unsubscribe;\n    unsubscribe = unsubscribe.onSnapshot(snapshot => {\n      const newTasks = snapshot.docs.map(task => ({\n        id: task.id,\n        ...task.data()\n      }));\n      setTasks(selectedProject === 'NEXT_7' ? newTasks.filter(task => moment(task.date, 'DD-MM-YYYY').diff(moment(), 'days') <= 7 && task.archived !== true) : newTasks.filter(task => task.archived !== true));\n      setArchivedTasks(newTasks.filter(task => task.archived !== false));\n    });\n    return () => unsubscribe();\n  }, [selectedProject]);\n  return {\n    tasks,\n    archivedTasks\n  };\n};\n\n_s(useTasks, \"lkbYbSuB/cNTkTVEXjLheUMZ+l8=\");\n\nexport const useProjects = () => {\n  _s2();\n\n  const [projects, setProjects] = useState([]);\n  useEffect(() => {\n    firebase.firestore().collection('projects').where('userId', '==', 'nfeCumoN').orderBy('projectId').get().then(snapshot => {\n      const allProjects = snapshot.docs.map(project => ({ ...project.data(),\n        docId: project.id\n      }));\n\n      if (JSON.stringify(allProjects) !== JSON.stringify(projects)) {\n        setProjects(allProjects);\n      }\n    });\n  }, [projects]);\n  return {\n    projects,\n    setProjects\n  };\n}; // const selectedProject = 1; \n// const { tasks, archivedTasks} = useTasks(selectedProject);\n//passing an empty array means we only want to run this once - after the component is mounted\n//without the array then it's just going to keep running over and over again\n//whatever is put into the array: if that chaanges, then the useEffect will run \n\n_s2(useProjects, \"TSrpuQX6QU8EgjQSxaAzj2u9i4o=\");","map":{"version":3,"sources":["/Users/matthewfang1999/Documents/CMU/F20/PUI/HW8/taskmanagerapp/src/hooks/index.js"],"names":["useState","useEffect","moment","firebase","collatedTasksExist","useTasks","selectedProject","tasks","setTasks","archivedTasks","setArchivedTasks","unsubscribe","firestore","collection","where","format","onSnapshot","snapshot","newTasks","docs","map","task","id","data","filter","date","diff","archived","useProjects","projects","setProjects","orderBy","get","then","allProjects","project","docId","JSON","stringify"],"mappings":"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","sourcesContent":["// import { useState, useEffect} from 'react';\n// import { firebase } from  '../firebase';\n// import { collatedTasksExist } from '../helpers';\n// import moment from 'moment';\n\n\n\n\n// export const useTasks = selectedProject => {\n//     const [tasks, setTasks] = useState([]);\n//     const [archivedTasks, setArchivedTasks] = useState([]);\n  \n//     useEffect(() => {\n//       let unsubscribe = firebase\n//         .firestore()\n//         .collection('tasks')\n//         .where('userId', '==', 'nfeCumoN');\n  \n//       unsubscribe =\n//         selectedProject && !collatedTasksExist(selectedProject)\n//           ? (unsubscribe = unsubscribe.where('projectId', '==', selectedProject))\n//           : selectedProject === 'TODAY'\n//           ? (unsubscribe = unsubscribe.where(\n//               'date',\n//               '==',\n//               moment().format('DD/MM/YYYY')\n//             ))\n//           : selectedProject === 'INBOX' || selectedProject === 0\n//           ? (unsubscribe = unsubscribe.where('date', '==', ''))\n//           : unsubscribe;\n\n// //-------------------------Getting tasks for next 7 days \n//       unsubscribe = unsubscribe.onSnapshot(snapshot => {\n//         const newTasks = snapshot.docs.map(task => ({\n//           id: task.id,\n//           ...task.data(),\n//         }));\n  \n//         setTasks(\n//           selectedProject === 'NEXT_7'\n//             ? newTasks.filter(\n//                 task =>\n//                   moment(task.date, 'DD-MM-YYYY').diff(moment(), 'days') <= 7 &&\n//                   task.archived !== true\n//               )\n//             : newTasks.filter(task => task.archived !== true)\n//         );\n//         setArchivedTasks(newTasks.filter(task => task.archived !== false));\n//       });\n  \n// //only want to check the projects when there's a new selected project\n// //all this code will run when selectedProject changes \n//       return () => unsubscribe();\n//     }, [selectedProject]);\n  \n//     return { tasks, archivedTasks };\n//   };\n\n\n\n\n\n\n\n//   export const useProjects = () => {\n//     const [projects, setProjects] = useState([]);\n  \n//     useEffect(() => {\n//       firebase\n//         .firestore()\n//         .collection('projects')\n//         .where('userId', '==', 'nfeCumoN')\n//         .orderBy('projectId')\n//         .get()\n//         .then(snapshot => {\n//           const allProjects = snapshot.docs.map(project => ({\n//             ...project.data(),\n//             docId: project.id,\n//           }));\n  \n//           if (JSON.stringify(allProjects) !== JSON.stringify(projects)) {\n//             setProjects(allProjects);\n//           }\n//         });\n//     }, [projects]);\n  \n//     return { projects, setProjects };\n//   };\n\n\n  import { useState, useEffect } from 'react';\nimport moment from 'moment';\nimport { firebase } from '../firebase';\nimport { collatedTasksExist } from '../helpers';\n\nexport const useTasks = selectedProject => {\n  const [tasks, setTasks] = useState([]);\n  const [archivedTasks, setArchivedTasks] = useState([]);\n\n  useEffect(() => {\n    let unsubscribe = firebase\n      .firestore()\n      .collection('tasks')\n      .where('userId', '==', 'nfeCumoN');\n\n    unsubscribe =\n      selectedProject && !collatedTasksExist(selectedProject)\n        ? (unsubscribe = unsubscribe.where('projectId', '==', selectedProject))\n        : selectedProject === 'TODAY'\n        ? (unsubscribe = unsubscribe.where(\n            'date',\n            '==',\n            moment().format('DD/MM/YYYY')\n          ))\n        : selectedProject === 'INBOX' || selectedProject === 0\n        ? (unsubscribe = unsubscribe.where('date', '==', ''))\n        : unsubscribe;\n\n    unsubscribe = unsubscribe.onSnapshot(snapshot => {\n      const newTasks = snapshot.docs.map(task => ({\n        id: task.id,\n        ...task.data(),\n      }));\n\n      setTasks(\n        selectedProject === 'NEXT_7'\n          ? newTasks.filter(\n              task =>\n                moment(task.date, 'DD-MM-YYYY').diff(moment(), 'days') <= 7 &&\n                task.archived !== true\n            )\n          : newTasks.filter(task => task.archived !== true)\n      );\n      setArchivedTasks(newTasks.filter(task => task.archived !== false));\n    });\n\n    return () => unsubscribe();\n  }, [selectedProject]);\n\n  return { tasks, archivedTasks };\n};\n\nexport const useProjects = () => {\n  const [projects, setProjects] = useState([]);\n\n  useEffect(() => {\n    firebase\n      .firestore()\n      .collection('projects')\n      .where('userId', '==', 'nfeCumoN')\n      .orderBy('projectId')\n      .get()\n      .then(snapshot => {\n        const allProjects = snapshot.docs.map(project => ({\n          ...project.data(),\n          docId: project.id,\n        }));\n\n        if (JSON.stringify(allProjects) !== JSON.stringify(projects)) {\n          setProjects(allProjects);\n        }\n      });\n  }, [projects]);\n\n  return { projects, setProjects };\n};\n\n\n\n// const selectedProject = 1; \n// const { tasks, archivedTasks} = useTasks(selectedProject);\n\n\n//passing an empty array means we only want to run this once - after the component is mounted\n//without the array then it's just going to keep running over and over again\n//whatever is put into the array: if that chaanges, then the useEffect will run "]},"metadata":{},"sourceType":"module"}